package wirego

/*
	!DO NOT EDIT THIS FILE!

	If you plan to create a golang plugin for Wireshark,
	you're looking at the wrong file.
	Take your chance with "example/wirego_example.go".

	You probably don't want to look at this file actually.
	Trust me.
*/

import (
	"context"
	"fmt"

	zmq "github.com/go-zeromq/zmq4"
)

type DissectResultFlattenEntry struct {
	Protocol string
	Info     string
	fields   []DissectResultFlatten
}
type DissectResultFlatten struct {
	parentIdx     int
	wiregoFieldId FieldId
	offset        int
	length        int
}

// Just a simple holder
type Wirego struct {
	listener           WiregoInterface
	resultsCacheEnable bool
	wiregoFieldIds     map[int]bool
	resultsCache       map[int]*DissectResultFlattenEntry

	//ZMQ
	zqmEndpoint string
	zmqContext  context.Context
	zmqSocket   zmq.Socket

	//Fetched and duplicated from plugin, to trick gc
	pluginName                       string
	pluginFilter                     string
	pluginDetectionHeuristicsParents []string
	pluginDetectionFilters           []DetectionFilter
	pluginFields                     []WiresharkField
}

// We use a static "object" here
var wg Wirego

func New(zqmEndpoint string, listener WiregoInterface) (*Wirego, error) {
	var err error
	wg.listener = listener
	wg.zqmEndpoint = zqmEndpoint
	wg.resultsCacheEnable = true

	wg.wiregoFieldIds = make(map[int]bool)
	wg.resultsCache = make(map[int]*DissectResultFlattenEntry)

	//Preload all "static" values to bypass the GC and keep local copies
	wg.pluginName = wg.listener.GetName()
	wg.pluginFilter = wg.listener.GetFilter()
	wg.pluginDetectionHeuristicsParents = wg.listener.GetDetectionHeuristicsParents()
	wg.pluginDetectionFilters = wg.listener.GetDetectionFilters()
	wg.pluginFields = wg.listener.GetFields()

	//Checks fields for duplicates
	for _, f := range wg.pluginFields {
		_, duplicate := wg.wiregoFieldIds[int(f.WiregoFieldId)]
		if duplicate {
			return nil, fmt.Errorf("failed to add wirego fields, duplicated WiregoFieldId: %d", f.WiregoFieldId)
		}
		wg.wiregoFieldIds[int(f.WiregoFieldId)] = true
	}

	//Setup ZMQ
	err = wg.zmqSetup()
	if err != nil {
		return nil, err
	}
	return &wg, nil
}

// ResultsCacheEnable enables or disables the results cache. By default, the results cache is enabled.
// If re-analyzing a packet makes sense for your protocol, disable this feature.
func (wg *Wirego) ResultsCacheEnable(enable bool) {
	wg.resultsCacheEnable = enable
}

/*
//export wirego_version_major
func wirego_version_major() C.int {
	return WIREGO_VERSION_MAJOR
}

//export wirego_version_minor
func wirego_version_minor() C.int {
	return WIREGO_VERSION_MINOR
}

//export wirego_plugin_name
func wirego_plugin_name() *C.char {
	if wg.listener == nil {
		return nil
	}
	return C.CString(wg.pluginName)
}

//export wirego_plugin_filter
func wirego_plugin_filter() *C.char {
	if wg.listener == nil {
		return nil
	}
	return C.CString(wg.pluginFilter)
}

//export wirego_get_fields_count
func wirego_get_fields_count() C.int {
	if wg.listener == nil {
		return 0
	}

	return C.int(len(wg.pluginFields))
}

//export wirego_get_field
func wirego_get_field(index int, wiregoFieldId *C.int, name **C.char, filter **C.char, valueType *C.int, display *C.int) C.int {
	*wiregoFieldId = -1
	*name = nil
	*filter = nil
	*valueType = -1
	*display = -1

	if (wg.listener == nil) || (index < 0) || (index >= len(wg.pluginFields)) {
		return C.int(-1)
	}

	f := wg.pluginFields[index]

	wg.wiregoFieldIds[int(f.WiregoFieldId)] = true
	*wiregoFieldId = C.int(f.WiregoFieldId)
	*name = C.CString(f.Name)
	*filter = C.CString(f.Filter)
	*valueType = C.int(f.ValueType)
	*display = C.int(f.DisplayMode)

	return C.int(0)
}

//export wirego_detection_heuristic
func wirego_detection_heuristic(packetNumber C.int, src *C.char, dst *C.char, layer *C.char, packet *C.char, packetSize C.int) C.int {
	if wg.listener == nil {
		return C.int(-1)
	}

	if (src == nil) || (dst == nil) || (layer == nil) || (packet == nil) || packetSize == 0 {
		return C.int(-1)
	}

	result := wg.listener.DetectionHeuristic(int(packetNumber), C.GoString(src), C.GoString(dst), C.GoString(layer), C.GoBytes(unsafe.Pointer(packet), packetSize))

	if result {
		return 1
	}
	return 0
}

//export wirego_result_get_protocol
func wirego_result_get_protocol(h C.int) *C.char {
	if wg.listener == nil || wg.resultsCache == nil {
		return nil
	}

	wg.lock.Lock()
	defer wg.lock.Unlock()
	desc, found := wg.resultsCache[h]
	if !found {
		return nil
	}

	return C.CString(desc.Protocol)
}

//export wirego_result_get_info
func wirego_result_get_info(h C.int) *C.char {
	if wg.listener == nil || wg.resultsCache == nil {
		return nil
	}

	wg.lock.Lock()
	defer wg.lock.Unlock()
	desc, found := wg.resultsCache[h]
	if !found {
		return nil
	}

	return C.CString(desc.Info)
}

//export wirego_result_get_fields_count
func wirego_result_get_fields_count(h C.int) C.int {
	if wg.listener == nil || wg.resultsCache == nil {
		return C.int(0)
	}

	wg.lock.Lock()
	defer wg.lock.Unlock()
	desc, found := wg.resultsCache[h]
	if !found {
		return C.int(0)
	}
	return C.int(len(desc.fields))
}

//export wirego_result_get_field
func wirego_result_get_field(h C.int, idx C.int, parentIdx *C.int, wiregoFieldId *C.int, offset *C.int, length *C.int) {
	*parentIdx = -1
	*wiregoFieldId = -1
	*offset = -1
	*length = -1

	if wg.listener == nil || wg.resultsCache == nil {
		return
	}

	wg.lock.Lock()
	defer wg.lock.Unlock()

	desc, found := wg.resultsCache[h]
	if !found {
		return
	}

	if idx >= C.int(len(desc.fields)) {
		return
	}
	*parentIdx = C.int(desc.fields[idx].parentIdx)
	*wiregoFieldId = C.int(desc.fields[idx].wiregoFieldId)
	*offset = C.int(desc.fields[idx].offset)
	*length = C.int(desc.fields[idx].length)
}

//export wirego_result_release
func wirego_result_release(h C.int) {
	if !resultsCacheEnable {
		delete(wg.resultsCache, h)
	}
}
*/

func (wg *Wirego) addFieldsRec(flatten *DissectResultFlattenEntry, parentIdx int, field *DissectField) {
	flatten.fields = append(flatten.fields, DissectResultFlatten{parentIdx: parentIdx, wiregoFieldId: field.WiregoFieldId, offset: field.Offset, length: field.Length})
	newParentIdx := len(flatten.fields) - 1

	for _, sub := range field.SubFields {
		wg.addFieldsRec(flatten, newParentIdx, &sub)
	}
}
